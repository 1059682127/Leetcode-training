package lt48

// 旋转图像
// 【原地】对图像（n*n 二维矩阵）顺时针旋转90度

// 思路：
// 这是 旋转数组 一题的进阶版。旋转数组的原地解法且时间复杂度较低（O(n)）的解法有 三次反转 和 环状替换
/// 而回到这题。三次反转并不适用，环状替换暂时不清楚

// 分析下顺时针旋转90度坐标的变化：
// 第0行变成第n-1列； 第1行变成i-2列；...这样所有元素就旋转完成了
// i行变n-1-i列， 所以坐标 (i, j) => (?, n-1-i)，?号处应该是j，所以是 (i, j) => (j, n-1-i)
// 1. 旋转过程中显然原值需要保存，如果使用辅助二维数组，这就很好做了，但本题不允许。
// 2. 退而求其次，不适用n*n数组，只使用n*1数组，也可以达到目的，就是比较绕
// 3. 想不出，看题解


// 给定 matrix =
//[
//  [1,2,3],
//  [4,5,6],
//  [7,8,9]
//],
//
//原地旋转输入矩阵，使其变为:
//[
//  [7,4,1],
//  [8,5,2],
//  [9,6,3]
//]
//

// 转置：沿主对角线镜像翻转，实现行列互换。遍历时只需要遍历主对角线以上或以下区域。

// 官方题解1. 转置加翻转
// 先转置矩阵，再翻转每一行。
// 已经达到最优时间复杂度O(N2)
func rotate(matrix [][]int) {
	//if len(matrix) < 2 {return}		// 如果是0*0或者1*1就没必要继续下去
	//// 不检查矩阵是否是 n*n (长宽一致)

	n := len(matrix)	// 矩阵的行数。列数与之相等

	// 转置矩阵
	for i:=0; i<n; i++ {
		for j:=i; j<n; j++ {	// 以j为列号，则说明这里遍历的是主对角线以上区域
			matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
		}
	}

	// 将每一行进行翻转，正常理解是沿矩阵竖向二分线进行镜像。代码实现则是对整行作左右交换。每行只需遍历左半部分
	for i:=0; i<n; i++ {
		for j:=0; j<n/2; j++ {
			matrix[i][j], matrix[i][n-1-j] = matrix[i][n-1-j], matrix[i][j]
		}
	}
}


// 官方题解2. 旋转四个矩形
// 方法1使用了两次矩阵操作，一次转置，一次各行翻转
// 这个解法直接利用旋转研究数据的移动。
// 图解见官方题解：https://leetcode-cn.com/problems/rotate-image/solution/xuan-zhuan-tu-xiang-by-leetcode/
// 文字不好描述
// 每一次都找出位置进行轮换的四个点，装入临时数组，遍历该临时数组，根据其再对矩阵相应位作调整
func rotate2(matrix [][]int) {
	n := len(matrix)	// 矩阵的行数。列数与之相等

	tmp := [4]int{0, 0, 0, 0}
	var row, col int
	// 只需要遍历矩阵四角之一（旋转90度）。
	for i:=0; i<n/2+n%2; i++ {	// i<n/2+n%2	+n%2是为了避免行为奇数，中间水平对称轴也是要旋转的，所以得加上
		for j:=0; j<n/2; j++ {	// j<n/2		列数则不需要，因为行区已经包含了这对称轴(右旋90度变成竖向对称轴)
												// 想象一个矩阵的四分之一沿其中心点右旋的样子

			row, col = i, j		// 记录当前行列号

			// 获取该轮要进行交换的四个方位的四个数据
			for k:=0; k<4; k++ {
				tmp[k] = matrix[row][col]
				row, col = col, n-1-row		// 找到当前点要右旋90度旋转到的目标点位置
			}

			// 利用tmp来实现直接换四个数据
			for k:=0; k<4; k++ {
				matrix[row][col] = tmp[(k+3)%4]		// 当前位置要填上向其移动过来的点的数据（也就是其左旋90度方位的点，或者叫右旋270度）
				row, col = col, n-1-row		// 找到当前点要旋转到的目标点位置
			}
		}
	}
}