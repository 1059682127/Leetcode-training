package lt20

// 有效的括号

//给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。
//
//有效字符串需满足：
//
//左括号必须用相同类型的右括号闭合。
//左括号必须以正确的顺序闭合。
//注意空字符串可被认为是有效字符串。
//
//示例 1:
//
//输入: "()"
//输出: true
//示例 2:
//
//输入: "()[]{}"
//输出: true
//示例 3:
//
//输入: "(]"
//输出: false
//示例 4:
//
//输入: "([)]"
//输出: false
//示例 5:
//
//输入: "{[]}"
//输出: true
//
//来源：力扣（LeetCode）
//链接：https://leetcode-cn.com/problems/valid-parentheses
//著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

// 思考
// 1.括号匹配，这类问题一向可以使用栈解决。


// '(' 40  ')' 41
// '[' 91  ']' 93
// '{' 123 '}' 125


// 1. 基于栈的解法
// O(n)/O(n)	// n为字符串长度
func isValid(s string) bool {
	n := len(s)
	if n==0 {return true}
	if n&1==1 {return false}	// n&1==1表示判断是否是奇数，如果是奇数，不可能配对

	// 配对表
	match := map[byte]byte{
		'(': ')',
		'[': ']',
		'{': '}',
	}	// 右括号为键则直接没有配对

	stack := make([]byte, 0)
	for i:=0; i<n; i++ {
		if len(stack)>0 && s[i]==match[stack[len(stack)-1]] {	// 栈顶有元素，就把栈顶元素和当前元素(字符)比较，如果配对，则弹出栈；否则压栈
			stack = stack[:len(stack)-1]
			continue
		}
		// 无论是栈顶有元素但没配对成功 还是 栈顶没元素， 都需要压栈(压栈之前检查字符合法性，也可以不检查，不检查浪费些空间，检查浪费时间)
		stack = append(stack, s[i])
	}

	// 最后检查栈是否为空，空则有效括号
	return len(stack)==0
}

// 官方题解也是基于栈的解法，并且从官方题解的描述来看，这类题，普通的数组遍历没法解决，必须使用栈或者类似栈的这种回溯