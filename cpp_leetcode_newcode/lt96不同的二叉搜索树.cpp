//lt96

/*
不同的二叉搜索树

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

示例:

输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
	\       /     /      / \      \
	 3     2     1      1   3      2
	/     /       \                 \
   2     1         2                 3
//思路1：动态规划

*/

class Solution {
public:
	//思路1：动态规划
	//给定一个有序序列 1 ... n，为了根据序列构建一棵二叉搜索树。我们可以遍历每个数字 i，将该数字作为树根，1 ... (i-1) 序列将成为左子树，(i+1) ... n 序列将成为右子树。
	//问题可以分解成规模较小的子问题。因此，我们可以存储并复用子问题的解，而不是递归的（也重复的）解决这些子问题，这就是动态规划法。

	//问题是计算不同二叉搜索树的个数。为此，我们可以定义两个函数：
	//G(n): 长度为n的序列的不同二叉搜索树个数。(求解的问题)
	//F(i,n): 以i为根的不同二叉搜索树个数

	//base sample:G(0) = 1, G(1) = 1;
	//状态转移：G(n) = F(1,n)+F(2,n)+...+F(n,n)
	//又F(i,n) eg:F(3,7) 左子序列 [1, 2] 构建左子树，从右子序列 [4, 5, 6, 7] 构建右子树，然后将它们组合(即笛卡尔积)  G(n) 和序列的内容无关，只和序列的长度有关。于是，F(3,7)=G(2)⋅G(4)
	//所以F(i-n) = G(i-1)G(n-i)
	//得到状态转移公式：G(n) = G(1-1)G(n-1) + ...+G(i-1)G(n-i)+....+G(n-1)G(n-n)

	//选取一个结点为根，就把结点切成左右子树，以这个结点为根的可行二叉树数量就是左右子树可行二叉树数量的乘积，所以总的数量是将以所有结点为根的可行结果累加起来。这其实是一个卡特兰数的模型

	//时间：O(N^2) ∑i=2~n i = (2+n)(n−1)/2
	//空间：0(N),dp使用
	int numTrees(int n) {
		vector<int> dp(n + 1);
		dp[0] = 1;
		dp[1] = 1;
		for (int i = 2; i <= n; ++i) {
			for (int j = 1; j <= i; ++j) {
				dp[i] += dp[j - 1] * dp[i - j];
			}
		}
		return dp[n];
	}
};