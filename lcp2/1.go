package lcp2


// LCP2 分式化简

// 将连分数化为最简
// 题目描述这里就不放了，leetcode

// 思考：
// 拿到题之后我的想法是将总问题化为子问题然后从前向后（或者从外至内）进行递归，但是递归外得到的结果可能不是最简
// 怎么求最简？这却又难到我了。假使说递归之后得到的分式没有任何规律，是任意的分式，那么化最简需要怎么做？
// 看了下题解区，又说不用化简...嗯，所以直接看别人的解法先学习吧


// 1. 题解区 homesway
func fraction(cont []int) []int {
	ans := []int{1,1}	// 最简分式的分子分母
	l := len(cont)
	if l==0 {return ans}
	ans[1] = cont[l-1]		// 先填充分母。 cont最后一位一定是分母，而其前一位相对来说则是常数
	for i:=l-2; i>=0; i-- {
		// 通分， fe
		ans[0], ans[1] = ans[1], cont[i] * ans[1] + ans[0]
		// 这里其实是先计算新ans[1]，再更新ans[0]为老ans[1]
	}
	ans[0] = ans[0] ^ ans[1]
	ans[1] = ans[0] ^ ans[1]
	ans[0] = ans[0] ^ ans[1]
	return ans
}


// 实际推导一下过程
// 例如cont = [1,2,3,4]
// 初始化 ans = [1, 1]
// ans赋值 ans = [1, 4]   这表示了最后的那个数 1/4
// 进入for循环：
// 		i=l-2=2; ans[1]=3*4+1, ans[0]=4; 现在ans代表的分数变成了 4/13
// 		i=1; ans[1]=2*13+4, ans[0]=13; 现在ans代表的分数变成了 13/30
// 		i=0; ans[1]=1*30+13, ans[0]=30; 现在ans代表的分数变成了 30/43
// 这个过程与手推一致，就是通过不断把分子分母颠倒实现通分
// 为啥最后还要有三次异或操作呢？
// a[0] = (a[0] ^ a[1]) ^ ((a[0] ^ a[1]) ^ a[1]) = a[1]
// a[1] = ((a[0] ^ a[1]) ^ a[1]) = a[0]
// 那么最后这三句只是把 a[0] a[1] 对调啊
// 奇奇怪怪
// 通过看其他题解明白了，这样的循环是多颠倒了一次的，所以最后要颠倒回来，只是这异或写得让人摸不着头脑


// 2. 题解区 彪了个彪
func fraction2(cont []int) []int {
	l := len(cont)
	num, den := 1,cont[l-1]	// 分子, 分母
	for i:=l-2; i>=0; i-- {
		num, den = den, cont[i] * den + num
	}
	// 需要注意的是，在上面的循环中是多颠倒了一次的，所以，返回时需要颠倒回来
	return []int{den, num}
}
