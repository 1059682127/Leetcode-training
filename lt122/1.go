package lt122


// 买卖股票的最佳时机II

//给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
//
//设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
//
//注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
//
//示例 1:
//
//输入: [7,1,5,3,6,4]
//输出: 7
//解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
//     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
//示例 2:
//
//输入: [1,2,3,4,5]
//输出: 4
//解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
//     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
//     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
//示例 3:
//
//输入: [7,6,4,3,1]
//输出: 0
//解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
//
//来源：力扣（LeetCode）
//链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii
//著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



// 3. 动态规划
// 动态规划解法
// 利用[状态]穷举所有可能，
// 模板：
// for 状态1 in 状态1范围：
//		for 状态2 in 状态2范围：
//			for ...
//				dp[状态1][状态2][...] = 择优(选择1，选择2，...)
//
// 选择：每天都有三种选择：买入buy、卖出sell、无操作(rest)。但买入只能在卖出之后，卖出也只能在买入之后，rest时手上可能有股票也可能没有
//		rest=1时可以卖出股票；rest=0时可以买入；k=0时不可以交易
// 状态： 天数(i), 至今(k)，当前有股票在手还是无(0表示无股票在手，1表示有,也就是rest的状态)
//		K是限制总交易次数，k是至今(第i天)最多可能进行的交易次数
// 		k从大到小，表示第i天最多交易k次；k-1是针对i-1而言的；k是最大次数限制，
//		随着交易进行，可以进行的最大交易次数在减少
//	注意： 一次交易由买入、卖出构成，至少需要两天。(也就是说如果题目说交易数不限，那么交易数也是最多是n/2，k若超过这个值，则相当于无穷大)
//
// 所有状态数： 天数n * 允许的最大交易数K * 2 (0/1)
// 所以穷举所有状态的式子就是：
// for 0<=i<n:
// 		for 1<=k<=K:
//			for s in [0,1]:
//				dp[i][k][s] = max(buy, sell, rest)
// 要求的最终答案就是 dp[n-1][K][0]。 (最后一天股票全部售出肯定比手上还持有利润大)
//
// 状态转移框架：
// 状态转移方程：
// dp[i][k][0] = max(buy[不允许], sell[昨天持有，今天卖了], rest[昨天没有，今天也没有]) = max(sell, rest)
//			= max(dp[i-1][k][1]+prices[i], dp[i-1][k][0])
// dp[i][k][1] = max(buy[昨天没有，今天买了], sell[不允许], rest[昨天持有，今天也持有]) = max(sell, rest)
//			= max(dp[i-1][k-1][0]-prices[i], dp[i-1][k][1])
//		注意这里k-1是指，昨天的交易次数肯定比今天少一次
//
// base case 基例
// dp[-1][k][0] = 0
// i=-1表示还未开始，利润为0
// dp[-1][k][1] = -infinity
// 还没开始不可能有股票在手，-infinity表示不可能
// dp[i][0][0] = 0
// k从1开始，0表示不允许交易，这时利润为0
// dp[i][0][1] = -infinity
// 不允许交易，则不可能持有股票，-infinity用来表示不可能
//
//
// 现在回到本题，本题中可以尽可能的完成更多的交易，多次买入卖出，也就是K=+infinity，这样的话k可以认为与k-1相等
// dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1]+prices[i])
// dp[i][1][1] = max(dp[i-1][k][1], dp[i-1][k-1][0]-prices[i]) = max(dp[i-1][k][1], dp[i-1][k][0]-prices[i])
// 状态变化与k无关，可以将其去掉
// dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i])
// dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])

func max(a,b int) int {if a>=b {return a} else {return b}}


// 动态规划
//201/201 cases passed (4 ms)
//Your runtime beats 96.53 % of golang submissions
//Your memory usage beats 5.01 % of golang submissions (3.6 MB)
func maxProfit(prices []int) int {
	n := len(prices)
	if n==0 {return 0}
	dp := make([][2]int, n)
	dp[0] = [2]int{0, -prices[0]}
	for i:=1; i<n; i++ {
		dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i])
		dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])
	}
	return dp[n-1][0]
}

// 动态规划优化内存
func maxProfit2(prices []int) int {
	n := len(prices)
	if n==0 {return 0}
	dp_0, dp_1 := 0, -prices[0]
	for i:=1; i<n; i++ {
		dp_0 = max(dp_0, dp_1+prices[i])
		dp_1 = max(dp_1, dp_0-prices[i])
	}
	return dp_0
}